\documentclass{beamer}

% Syntax highlighting
\usepackage{minted}
\usepackage{alltt}
\usepackage{color}
\definecolor{mainorange}{HTML}{EC811B}
\newcommand\hi[1]{{\color{mainorange} \textbf{#1}}}

\usetheme{metropolis}

\title{Intro To Rust}
\date{\today}
\author{Danilo Bargen, Raphael Nestler}
\institute{Coredump Rapperswil}

\begin{document}

\maketitle

% ----------------------------------------------------------------- %

\section{What is Rust?}

%%%

\begin{frame}{What is Rust?}
	\begin{quote}
		«Rust is a systems programming language\\
		that runs blazingly fast, prevents nearly all segfaults,\\
		and guarantees thread safety.»\\
		\vspace{0.5em}
		{\normalfont \small --- www.rust-lang.org}
	\end{quote}
\end{frame}

%%%

\begin{frame}{What's wrong with systems languages?}
	\begin{itemize}
		\item It's difficult to write secure code.
		\item It's very difficult to write multithreaded code.
	\end{itemize}
	These are the problems Rust was made to address.
\end{frame}

%%%

\begin{frame}{Quick Facts about Rust}
	(As of September 2015)
	\begin{itemize}
		\item Started by Mozilla employee Graydon Hoare
		\item First announced by Mozilla in 2010
		\item Community driven development
		\item First stable release: 1.0 in May 2015
		\item Latest stable release: 1.3
		\item 46'484 commits on Github
		\item Largest project written in Rust: Servo
	\end{itemize}
\end{frame}

%%%

\begin{frame}{Features}
	\begin{itemize}
		\item Zero-cost abstractions
		\item Move semantics
		\item Guaranteed memory safety
		\item Threads without data races
		\item Trait based generics
		\item Pattern matching
		\item Type inference
		\item Minimal runtime, no GC
		\item Efficient C bindings
	\end{itemize}
\end{frame}

% ----------------------------------------------------------------- %

\section{What is Type Safety?}

%%%

\begin{frame}[fragile]{A C Program}
\begin{minted}{c}
int main(int argc, char **argv) {
    unsigned long a[1];
    a[3] = 0x7ffff7b36cebUL;
    return 0;
}
\end{minted}
	According to C99, undefined behavior. Output:

	{\footnotesize \tt undef: Error: .netrc file is readable by others.\\
	undef: Remove password or make file unreadable by others.}
\end{frame}

%%%

\begin{frame}{Definitions}
	\begin{itemize}
		\item If a program has been written so that no possible execution can
			exhibit undefined behavior, we say that program is \textbf{well defined}.
		\item If a language’s type system ensures that every program is well
			defined, we say that language is \textbf{type safe}.
	\end{itemize}
\end{frame}

%%%

\begin{frame}[fragile]{Type Safe Languages}
	\begin{itemize}
		\item C and C++ are not type safe.
		\item Python is type safe:
\begin{minted}[fontsize=\footnotesize]{python}
>>> a = [0]
>>> a[3] = 0x7ffff7b36ceb
Traceback (most recent call last):
File "", line 1, in <module>
IndexError: list assignment index out of range
>>>
\end{minted}
		\item Java, JavaScript, Ruby, and Haskell are also type safe.
	\end{itemize}
\end{frame}

%%%

\begin{frame}{It's Ironic.}
	C and C++ are not type safe.

	Yet they are being used to implement the foundations of a system.

	Rust tries to resolve that tension
\end{frame}

% ----------------------------------------------------------------- %

\section{Reading Rust}

%%%

\begin{frame}[fragile,t]{Example 1}
\begin{alltt}
\hi{fn gcd}(mut n: u64, mut m: u64) \hi{->} u64 \{
    assert!(n != 0 && m != 0);
    while m != 0 \{
        if m < n \{
            let t = m; m = n; n = t;
        \}
        m = m % n;
    \}
    n
\}
\end{alltt}
\end{frame}

%%%

\begin{frame}[fragile,t]{Example 1}
\begin{alltt}
fn gcd(\hi{mut} n: u64, \hi{mut} m: u64) -> u64 \{
    assert!(n != 0 && m != 0);
    while m != 0 \{
        if m < n \{
            let t = m; m = n; n = t;
        \}
        m = m % n;
    \}
    n
\}
\end{alltt}
\end{frame}

%%%

\begin{frame}[fragile,t]{Example 1}
\begin{alltt}
fn gcd(mut \hi{n: u64}, mut \hi{m: u64}) -> u64 \{
    assert!(n != 0 && m != 0);
    while m != 0 \{
        if m < n \{
            let t = m; m = n; n = t;
        \}
        m = m % n;
    \}
    n
\}
\end{alltt}
\end{frame}

%%%

\begin{frame}[fragile,t]{Example 1}
\begin{alltt}
fn gcd(mut n: u64, mut m: u64) -> u64 \{
    \hi{assert!}(n != 0 && m != 0);
    while m != 0 \{
        if m < n \{
            let t = m; m = n; n = t;
        \}
        m = m % n;
    \}
    n
\}
\end{alltt}
\end{frame}

%%%

\begin{frame}[fragile,t]{Example 1}
\begin{alltt}
fn gcd(mut n: u64, mut m: u64) -> u64 \{
    assert!(n != \hi{0} && m != \hi{0});
    while m != \hi{0} \{
        if m < n \{
            let t = m; m = n; n = t;
        \}
        m = m % n;
    \}
    n
\}
\end{alltt}
\end{frame}

%%%

\begin{frame}[fragile,t]{Example 1}
\begin{alltt}
fn gcd(mut n: u64, mut m: u64) -> u64 \{
    assert!(n != 0 && m != 0);
    while m != 0 \{
        if m < n \{
            \hi{let t = m}; m = n; n = t;
        \}
        m = m % n;
    \}
    n
\}
\end{alltt}
\end{frame}

%%%

\begin{frame}[fragile,t]{Example 1}
\begin{alltt}
fn gcd(mut n: u64, mut m: u64) -> u64 \{
    assert!(n != 0 && m != 0);
    \hi{while m != 0 \{}
        \hi{if m < n \{}
            let t = m; m = n; n = t;
        \hi{\}}
        m = m % n;
    \hi{\}}
    n
\}
\end{alltt}
\end{frame}

%%%

\begin{frame}[fragile,t]{Example 1}
\begin{alltt}
fn gcd(mut n: u64, mut m: u64) -> u64 \{
    assert!(n != 0 && m != 0);
    while m != 0 \{
        if m < n \{
            let t = m; m = n; n = t;
        \}
        m = m % n;
    \}
    \hi{n}
\}
\end{alltt}
\end{frame}

%%%

\begin{frame}[fragile]{Example 2: Generics}

\begin{minted}{rust}
fn min<T: Ord>(a: T, b: T) -> T {
    if a <= b { a } else { b }
}
\end{minted}
\pause
\begin{minted}{rust}
...

min(10i8,  20)    == 10;    // T is i8
min(10,    20u32) == 10;    // T is u32
min("abc", "xyz") == "abc"; // Strings are Ord

min(10i32, "xyz"); // error: mismatched types
\end{minted}

\end{frame}

%%%

\begin{frame}[fragile]{Example 3: Generic Types}
\begin{minted}{rust}
struct Range<Idx> {
    start: Idx,
    end: Idx,
}
\end{minted}
\pause
\begin{minted}{rust}
...

Range { start: 200, end: 800 }  // OK
Range { start: 1.3, end: 4.7 }  // Also OK
\end{minted}
\end{frame}

%%%

\begin{frame}[fragile]{Example 4: Enumerations}
\begin{minted}{rust}
enum Option<T> {
    Some(T),
    None
}
\end{minted}
\end{frame}

%%%

\begin{frame}[fragile]{Example 5: Application of Option<T>}
\begin{minted}{rust}
fn safe_div(n: i32, d: i32) -> Option<i32> {
    if d == 0 {
        return None;
    }
    Some(n / d)
}
\end{minted}
\end{frame}

%%%

\begin{frame}[fragile]{Example 6: Matching an Option}
\begin{minted}{rust}
match safe_div(num, denom) {
    None => println!("No quotient."),
    Some(v) => println!("Quotient is {}.", v)
}
\end{minted}
\end{frame}

%%%

\begin{frame}[fragile]{Example 7: Traits}
\begin{minted}{rust}
trait HasArea {
    fn area(&self) -> f64;
}
\end{minted}
\end{frame}

%%%

\begin{frame}[fragile]{Example 8: Trait Implementation}
\begin{minted}{rust}
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&self) -> f64 {
       consts::PI * (self.radius * self.radius)
    }
}
\end{minted}
\end{frame}

%%%

\begin{frame}[fragile]{Example 9: Default Methods}
\begin{minted}{rust}
trait Validatable {
    fn is_valid(&self) -> bool;
    fn is_invalid(&self) -> bool {
        !self.is_valid()
    }
}
\end{minted}
\end{frame}

%%%

\begin{frame}[fragile]{Example 10: Trait Composition}
\begin{minted}{rust}
trait Foo {
    fn foo(&self);
}

trait FooBar : Foo {
    fn foobar(&self);
}
\end{minted}
\end{frame}

\end{document}
